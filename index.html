<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Play with C++17</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h1 id="play-with-c17">Play with C++17</h1>

<p>Information and Examples to experience C++17.</p>

<p>[Last update: Feb 17, 2017)</p>

<p>This document has been written by <a href="http://marcoarena.wordpress.com">Marco Arena</a> for some <a href="http://italiancpp.org">Italian C++ Community</a> Meetups.</p>

<p><div class="toc">
<ul>
<li><a href="#play-with-c17">Play with C++17</a><ul>
<li><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#online-compilers-to-play-with-c17">Online compilers to play with C++17</a></li>
</ul>
</li>
<li><a href="#language">Language</a><ul>
<li><a href="#structured-bindings">Structured bindings</a></li>
<li><a href="#template-argument-deduction-for-class-templates">Template argument deduction for class templates</a></li>
<li><a href="#ifswitch-statements-with-initializers">if/switch statements with initializers</a></li>
<li><a href="#folding-expressions">Folding expressions</a></li>
</ul>
</li>
<li><a href="#library-additions">Library Additions</a><ul>
<li><a href="#stringview">string_view</a></li>
<li><a href="#associative-containers-additions">associative containers additions</a><ul>
<li><a href="#insertorassign">insert_or_assign</a></li>
<li><a href="#tryemplace">try_emplace</a></li>
<li><a href="#extract">extract</a></li>
<li><a href="#merge">merge</a></li>
</ul>
</li>
<li><a href="#optional">optional</a></li>
<li><a href="#any">any</a></li>
<li><a href="#variant">variant</a></li>
</ul>
</li>
<li><a href="#attributes">Attributes</a></li>
<li><a href="#generic-programming">Generic Programming</a><ul>
<li><a href="#apply-invoke">apply &amp; invoke</a></li>
<li><a href="#makefromtuple">make_from_tuple</a></li>
<li><a href="#if-constexpr">if constexpr</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</p>



<h3 id="introduction">Introduction</h3>

<ul>
<li>C++17 has many more “tiny” features than C++11</li>
<li>Lots of library additions have been used and discussed for years in the industry</li>
<li>It’s a major release of the language and will act as a springboard for C++20</li>
<li>Compiler support: <a href="http://en.cppreference.com/w/cpp/compiler_support">http://en.cppreference.com/w/cpp/compiler_support</a></li>
<li><strong>GCC</strong> is language-complete: <a href="https://gcc.gnu.org/projects/cxx-status.html#cxx11">status</a></li>
<li><strong>Clang</strong> is ~language-complete: <a href="https://clang.llvm.org/cxx_status.html">status</a></li>
<li><strong>Visual C++</strong>: <a href="https://docs.microsoft.com/en-us/cpp/cpp-conformance-improvements-2017">news</a></li>
<li>Another great presentation: <a href="https://jfbastien.github.io/what-is-cpp17/#/8/1">https://jfbastien.github.io/what-is-cpp17/#/8/1</a></li>
<li>Another great cheatsheet: <a href="https://github.com/AnthonyCalandra/modern-cpp-features#structured-bindings">https://github.com/AnthonyCalandra/modern-cpp-features#structured-bindings</a></li>
</ul>



<h3 id="online-compilers-to-play-with-c17">Online compilers to play with C++17</h3>

<p>GCC and Clang: <a href="http://melpon.org/wandbox">http://melpon.org/wandbox</a></p>

<p>Visual C++: <a href="http://webcompiler.cloudapp.net/">http://webcompiler.cloudapp.net/</a></p>



<h2 id="language">Language</h2>



<h3 id="structured-bindings">Structured bindings</h3>

<p>Paper: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0217r2.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0217r2.html</a></p>

<p>Disappointment from the past:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>&gt; MakeRGBa() { ... }

<span class="hljs-keyword">int</span> r, g, b; <span class="hljs-keyword">float</span> a;
tie(r, g, b, a) = MakeRGBa();

<span class="hljs-stl_container"><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 3&gt;</span> MakeRGB();
<span class="hljs-comment">// won't compile</span>
<span class="hljs-keyword">int</span> r, g, b;
tie(r, g, b) = MakeRGB();

<span class="hljs-keyword">struct</span> RGBa
{
   <span class="hljs-keyword">int</span> r, g, b;
   <span class="hljs-keyword">float</span> a;
};
RGBa MakeRGBa();

<span class="hljs-keyword">int</span> r, g, b; <span class="hljs-keyword">float</span> a;
<span class="hljs-comment">// won't compile</span>
tie(r, g, b, a) = MakeRGBa();</code></pre>

<p>Types that are <strong>Destructurable</strong> can benefit of <em>Structured bindings</em>:</p>

<ul>
<li>Either all non-static data members: <br>
<ul><li>Must be public</li>
<li>Must be direct members of the type or members of the same public base class of the type</li>
<li>Cannot be anonymous unions</li></ul></li>
<li>Or the type has: <br>
<ul><li>An obj.get&lt;&gt;() method or an ADL-able get&lt;&gt;(obj) overload</li>
<li>Specializations of std::tuple_size&lt;&gt; and std::tuple_element&lt;&gt;</li></ul></li>
</ul>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">auto</span> [r, g, b, a] = MakeRGBa();</code></pre>

<p>Let’s use structured bindings to beautifully iterate on a std::map:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;</span> nameToAge;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [name, age] : nameToAge)
{
   <span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">" has "</span> &lt;&lt; age &lt;&lt; <span class="hljs-string">" years\n"</span>;
}</code></pre>

<p>Note: Structured binding <strong>does not copy values</strong>, rather it references them:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Foo
{
  ~Foo() { <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"dtor\n"</span>; }
  <span class="hljs-keyword">int</span> i, j;
};

Foo make()
{
  <span class="hljs-keyword">return</span> { <span class="hljs-number">1</span>, <span class="hljs-number">3</span> };
}

{
  <span class="hljs-keyword">auto</span> [a, b] = make();
  <span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;
}</code></pre>

<p>Will print:</p>



<pre class="prettyprint"><code class=" hljs ">1, 3
dtor
</code></pre>

<p>Play: <a href="http://melpon.org/wandbox/permlink/DxWo0TiMeWG6TFSo">http://melpon.org/wandbox/permlink/DxWo0TiMeWG6TFSo</a></p>



<h3 id="template-argument-deduction-for-class-templates">Template argument deduction for class templates</h3>

<p>Documentation: <a href="http://en.cppreference.com/w/cpp/language/class_template_deduction">http://en.cppreference.com/w/cpp/language/class_template_deduction</a></p>

<p>Disappointment from the past:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;
<span class="hljs-keyword">class</span> LambdaVisitor : SomeVisitor 
{
   Func visitFn;
<span class="hljs-keyword">public</span>:
   LambdaVisitor(Func f) : visitFn{f} {}
   <span class="hljs-keyword">void</span> Visit(<span class="hljs-keyword">const</span> Node&amp; node) { visitFn(node); }
   <span class="hljs-comment">// ...</span>
};

<span class="hljs-comment">// make function to deduce 'Func'</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt; 
LambdaVisitor&lt;Func&gt; MakeLambdaVisitor(Func f) 
{
   <span class="hljs-keyword">return</span> {f};
}

<span class="hljs-keyword">auto</span> visitor = MakeLambdaVisitor([](<span class="hljs-keyword">const</span> Node&amp; n) {...});</code></pre>

<p>What if LambdaVisitor has “scoped” ownership (e.g. is not copyable nor moveable)?</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span>&lt;typenameFunc&gt;
<span class="hljs-keyword">class</span> LambdaVisitor: SomeVisitor 
{
   Funcvisit Fn; lock_guard&lt;mutex&gt; l;
   <span class="hljs-comment">// the rest is the same as before</span></code></pre>

<p>C++17 introduces “Template argument deduction for class templates”:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">class</span> LambdaVisitor; <span class="hljs-comment">// same as before</span>

<span class="hljs-comment">// don't need the make-function anymore</span>

LambdaVisitor visitor{ [](<span class="hljs-keyword">const</span> Node&amp; n) {...} };</code></pre>

<p>See <a href="http://en.cppreference.com/w/cpp/language/class_template_deduction#User-defined_deduction_guides">here</a> for more details on <strong>custom deduction guides</strong>.</p>

<p>Play: <a href="http://melpon.org/wandbox/permlink/yeP0bQKndcM8O6vZ">http://melpon.org/wandbox/permlink/yeP0bQKndcM8O6vZ</a></p>



<h3 id="ifswitch-statements-with-initializers">if/switch statements with initializers</h3>

<p>Documentation: <a href="http://en.cppreference.com/w/cpp/language/if">http://en.cppreference.com/w/cpp/language/if</a></p>

<p>New versions of the if and switch statements which simplify common code patterns and help users keep scopes tight:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;</span> m = { {<span class="hljs-string">"A"</span>, <span class="hljs-number">1</span>}, {<span class="hljs-string">"B"</span>, <span class="hljs-number">2</span> };
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> it = m.find(<span class="hljs-string">"B"</span>); it!=end(m))
{
  <span class="hljs-comment">// ...</span>
}</code></pre>

<p>Play: <a href="http://melpon.org/wandbox/permlink/ptdZG2VZAGs4EGEb">http://melpon.org/wandbox/permlink/ptdZG2VZAGs4EGEb</a></p>



<h3 id="folding-expressions">Folding expressions</h3>

<p>Documentation: <a href="http://en.cppreference.com/w/cpp/language/fold">http://en.cppreference.com/w/cpp/language/fold</a></p>

<p>Reduce (<em>fold</em>) a parameter pack over a binary operator.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-keyword">auto</span> sum(Args... args)
{
    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span> + ... + args);
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span>... T&gt;
<span class="hljs-keyword">void</span> for_each(F fun, T&amp;&amp;... args)
{
    (fun (<span class="hljs-built_in">std</span>::forward&lt;T&gt;(args)), ...);
}


<span class="hljs-built_in">cout</span> &lt;&lt; sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>) &lt;&lt; endl;

for_each([](<span class="hljs-keyword">auto</span> elem) {
    <span class="hljs-built_in">cout</span> &lt;&lt; elem &lt;&lt; endl;
}, <span class="hljs-number">1</span>, <span class="hljs-string">"hello"</span>, <span class="hljs-number">10.0</span>);</code></pre>

<p>More on <a href="http://www.italiancpp.org/2015/06/15/folding-expressions">this article by Marco Alesiani</a>.</p>

<p>Play: <a href="http://melpon.org/wandbox/permlink/9sBbZ3JbW5PtyPDg">http://melpon.org/wandbox/permlink/9sBbZ3JbW5PtyPDg</a></p>



<h2 id="library-additions">Library Additions</h2>

<p>C++17 merges many library components that have been in the ecosystem for a long time into the standard. <br>
The good news is that we already have a long experience with such additions.</p>



<h3 id="stringview">string_view</h3>

<p>What’s ugly with the following code?</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span> split(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* delims)
{
  <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span> ret;

  <span class="hljs-built_in">string</span>::size_type start = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">auto</span> pos = str.find_first_of(delims, start);
  <span class="hljs-keyword">while</span> (pos != <span class="hljs-built_in">string</span>::npos)
  {
     <span class="hljs-keyword">if</span> (pos != start)
     {
        ret.push_back(str.substr(start, pos - start));
     }
     start = pos + <span class="hljs-number">1</span>;
     pos = str.find_first_of(delims, start);
  }
  <span class="hljs-keyword">if</span> (start &lt; str.length())
  ret.push_back(str.substr(start, str.length() - start));
  <span class="hljs-keyword">return</span> ret;
}</code></pre>

<p>Basically, I don’t want to reallocate strings that are already part of the string that I’m splitting. <br>
Can I use offsets?</p>

<p>I can do better: I can use string_views:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;string_view&gt;</span> split(string_view str, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* delims)
{
   <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;string_view&gt;</span> ret;

   string_view::size_type start = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">auto</span> pos = str.find_first_of(delims, start);
   <span class="hljs-keyword">while</span> (pos != string_view::npos)
   {
      <span class="hljs-keyword">if</span> (pos != start)
      {
         ret.push_back(str.substr(start, pos - start));
      }
      start = pos + <span class="hljs-number">1</span>;
      pos = str.find_first_of(delims, start);
   }
   <span class="hljs-keyword">if</span> (start &lt; str.length())
      ret.push_back(str.substr(start, str.length() - start));
   <span class="hljs-keyword">return</span> ret;
}</code></pre>

<p>Or, more generic:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Action&gt;
<span class="hljs-keyword">void</span> on_each_token(string_view str, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* delims, Action action)
{
   string_view::size_type start = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">auto</span> pos = str.find_first_of(delims, start);
   <span class="hljs-keyword">while</span> (pos != string_view::npos)
   {
      <span class="hljs-keyword">if</span> (pos != start)
      {
         action(str.substr(start, pos - start));
      }
      start = pos + <span class="hljs-number">1</span>;
      pos = str.find_first_of(delims, start);
   }
   <span class="hljs-keyword">if</span> (start &lt; str.length())
      action(str.substr(start, str.length() - start));
}</code></pre>

<p>string_view is an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero. <br>
I repeat: string_view is a reference. This means: it does not participate in the ownership of the sequence.</p>

<p>Typical implementations:</p>

<ul>
<li>const char pointer and a size;</li>
<li>couple of pointers;</li>
</ul>

<p>You can imagine string_view as a smart const char* which provides any const member function of std::string as well as a few handy utilities to reduce its span. You cannot enlarge a string_view until you reassign it.</p>

<p>First of all, string_view is an <strong>adapter</strong>: different string types cam be adapted into a std::string-like container through string_view:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">CString cstr = ...
string_view cstrv {cstr.GetString()};

<span class="hljs-built_in">string</span> stdstr = ...
string_view stdstrv {stdstr};

QString qstr = ...
string_view qstrv {qstr.toLatin1().constData()};

<span class="hljs-comment">// only one implementation</span>
ReturnType readonly_on_string_function(string_view sv); <span class="hljs-comment">// only one implementation</span></code></pre>

<p>Whenever you can do operations that are just the matter of “moving an offset” on the original string, string_view is your best friend:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">string_view sv = name.GetString(); <span class="hljs-comment">// GetString() returns a null-terminated const char*</span>
sv.remove_prefix(<span class="hljs-built_in">std</span>::min(sv.find_first_not_of(<span class="hljs-string">" "</span>), sv.size())); 
sv.remove_suffix(<span class="hljs-built_in">std</span>::min(sv.size()-sv.find_last_not_of(<span class="hljs-string">" "</span>)-<span class="hljs-number">1</span>, sv.size())); </code></pre>

<p>Does it recall you anything?</p>

<p>Yes, <strong>trim</strong>. Without creating a new string instance.</p>

<p>Play: <a href="http://melpon.org/wandbox/permlink/uITUQzX4ytMIG7n6">http://melpon.org/wandbox/permlink/uITUQzX4ytMIG7n6</a></p>

<p>Some string_view pitfalls: <a href="https://marcoarena.wordpress.com/2017/01/03/string_view-odi-et-amo/">https://marcoarena.wordpress.com/2017/01/03/string_view-odi-et-amo/</a></p>



<h3 id="associative-containers-additions">associative containers additions</h3>

<p>Note: examples and documentation consider only std::map. The same holds for other associative containers.</p>



<h4 id="insertorassign">insert_or_assign</h4>

<p>Documentation: <a href="http://en.cppreference.com/w/cpp/container/map/insert_or_assign">http://en.cppreference.com/w/cpp/container/map/insert_or_assign</a></p>

<p>A way to write the classical “insert or update” idiom:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;
<span class="hljs-built_in">string</span>&amp; insert_or_assign(<span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;K, V&gt;</span>&amp; m, K&amp;&amp; k, V&amp;&amp; v) 
{
    <span class="hljs-keyword">auto</span> p = m.equal_range(k);
    <span class="hljs-keyword">if</span> (p.first != p.second)
        <span class="hljs-keyword">return</span> p.first-&gt;second = forward&lt;V&gt;(v);
    <span class="hljs-keyword">return</span> m.emplace_hint(p.first, k, forward&lt;V&gt;(v))-&gt;second;
}

<span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt;</span> m;
insert_or_assign(m, <span class="hljs-number">10</span>, <span class="hljs-string">"hello world C++17!"</span>s);
insert_or_assign(m, <span class="hljs-number">20</span>, <span class="hljs-string">"associative containers 2.0"</span>s);</code></pre>

<p>Finally, C++17 makes makes this part of the container’s interface:</p>



<pre class="prettyprint"><code class="language-cpp hljs ">m.insert_or_assign(<span class="hljs-number">10</span>, <span class="hljs-string">"hello world C++17!"</span>s);
m.insert_or_assign(<span class="hljs-number">20</span>, <span class="hljs-string">"associative containers 2.0"</span>s);</code></pre>

<p>Why this is even better than any hand-made “insert or update”: <br>
* implementers may take advantage or internal details of the container; <br>
* unordered containers finally computes hash only once (they ignore hints).</p>



<h4 id="tryemplace">try_emplace</h4>

<p>Documentation: <a href="http://en.cppreference.com/w/cpp/container/map/try_emplace">http://en.cppreference.com/w/cpp/container/map/try_emplace</a></p>

<p>More or less like emplace but with two main differences: <br>
1. if the insertion does not happen, does not move from rvalue arguments (emplace/insert leave that unspecified); <br>
2. treats the key and the arguments to the mapped_type separately (emplace requires the arguments to construct a pair).</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, unique_ptr&lt;<span class="hljs-keyword">int</span>&gt;</span>&gt; m2;
m2[<span class="hljs-string">"A"</span>] = <span class="hljs-keyword">nullptr</span>;  
ptr = make_unique&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">23</span>);
m2.try_emplace(<span class="hljs-string">"A"</span>, move(ptr));
assert(ptr); <span class="hljs-comment">// will never fire (1)</span>

<span class="hljs-comment">// spot the differences (2):</span>
<span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;</span> m3;
m3.emplace(piecewise_construct, forward_as_tuple(<span class="hljs-string">"pippo"</span>), forward_as_tuple(<span class="hljs-number">5</span>, <span class="hljs-string">'A'</span>));
<span class="hljs-built_in">cout</span> &lt;&lt; m3[<span class="hljs-string">"pippo"</span>] &lt;&lt; <span class="hljs-string">"\n"</span>;
m3.try_emplace(<span class="hljs-string">"pluto"</span>, <span class="hljs-number">5</span>, <span class="hljs-string">'A'</span>); <span class="hljs-comment">// cute</span>
<span class="hljs-built_in">cout</span> &lt;&lt; m3[<span class="hljs-string">"pluto"</span>] &lt;&lt; <span class="hljs-string">"\n\n"</span>;</code></pre>



<h4 id="extract">extract</h4>

<p>Documentation: <a href="http://en.cppreference.com/w/cpp/container/map/extract">http://en.cppreference.com/w/cpp/container/map/extract</a></p>

<p>Unlinks a node from an associative container. The node can be found either by position (by passing a <strong>valid</strong> const_iterator) or by key.  <br>
In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed (rebalancing may occur, as with erase()). <br>
extract returns a <strong>node handle</strong> that owns the extracted element, or <em>empty</em> <strong>node handle</strong> in case the element is not found by key.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;</span> langs { {<span class="hljs-string">"apple"</span>, <span class="hljs-string">"obj-c"</span>}, {<span class="hljs-string">"ms"</span>, <span class="hljs-string">"c#"</span>} };
<span class="hljs-keyword">auto</span> elemHandle = langs.extract(<span class="hljs-string">"microsoft"</span>);
assert(langs.count(<span class="hljs-string">"microsoft"</span>) == <span class="hljs-number">0</span>); <span class="hljs-comment">// the node has been physically extracted from the map</span>
elemHandle.key() = <span class="hljs-string">"Microsoft"</span>;
langs.insert(move(elemHandle)); <span class="hljs-comment">// move it back</span>
assert(!elemHandle); <span class="hljs-comment">// the handle is not valid anymore</span></code></pre>

<p>extract is the only way to change a key of a map element without reallocation:</p>



<h4 id="merge">merge</h4>

<p>Documentation: <a href="http://en.cppreference.com/w/cpp/container/map/merge">http://en.cppreference.com/w/cpp/container/map/merge</a></p>

<p>Attempts to extract (“splice”) each element in source and insert it into *this using the the comparison object of *this. If there is an element in *this with key equivalent to the key of an element from source, then that element is not extracted from source. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into *this, not into source.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;</span> oldContacts = { 
  {<span class="hljs-string">"antonio"</span>, <span class="hljs-string">"1234"</span>}, {<span class="hljs-string">"franco"</span>, <span class="hljs-string">"34412"</span>}, {<span class="hljs-string">"gpad"</span>, <span class="hljs-string">"166101010"</span>} 
};
<span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;</span> newContacts = { 
  {<span class="hljs-string">"marco"</span>, <span class="hljs-string">"23123"</span>}, {<span class="hljs-string">"gpad"</span>, <span class="hljs-string">"8991234"</span>} 
};

<span class="hljs-comment">// nodes are physically extracted from OldContacts, duplicates are skipped</span>
newContacts.merge(oldContacts); 
<span class="hljs-comment">/* newContacts = 
  {"antonio", "1234"}, 
  {"franco", "34412"}, 
  {"gpad", "8991234"}, 
  {"marco", "23123"} 
*/</span></code></pre>

<p>Play: <a href="http://melpon.org/wandbox/permlink/hWeMmkSDUd4bNHk3">http://melpon.org/wandbox/permlink/hWeMmkSDUd4bNHk3</a></p>



<h3 id="optional">optional</h3>

<p>Documentation: <a href="http://en.cppreference.com/w/cpp/utility/optional">http://en.cppreference.com/w/cpp/utility/optional</a></p>

<p>Manages an optional contained value, i.e. a value that may or may not be present. Any instance of optional at any given point in time either contains a value or does not contain a value.</p>



<pre class="prettyprint"><code class="language-cpp hljs ">optional&lt;Message&gt; m = TryReceive(source);
<span class="hljs-keyword">if</span> (m)
{
 <span class="hljs-comment">// use *m or m.value()</span>
}</code></pre>

<p>optional works nicely with <strong>chaining</strong>.</p>

<p>Play: <a href="http://melpon.org/wandbox/permlink/Ky3M1j2BJe5sCLc3">http://melpon.org/wandbox/permlink/Ky3M1j2BJe5sCLc3</a></p>



<h3 id="any">any</h3>

<p>Documentation: <a href="http://en.cppreference.com/w/cpp/experimental/any">http://en.cppreference.com/w/cpp/experimental/any</a></p>

<p>Type-safe container for single values of any type.</p>



<pre class="prettyprint"><code class="language-cpp hljs ">any a = <span class="hljs-string">"hello"</span>s; <span class="hljs-comment">// contains a string</span>
<span class="hljs-keyword">auto</span>&amp; str = any_cast&lt;<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;&gt;(a);
a = <span class="hljs-number">10</span>; <span class="hljs-comment">// contains int</span>
<span class="hljs-keyword">auto</span> i = any_cast&lt;<span class="hljs-keyword">int</span>&gt;(a);</code></pre>

<p>Play: <a href="http://melpon.org/wandbox/permlink/3DMMCjwpagDf3W00">http://melpon.org/wandbox/permlink/3DMMCjwpagDf3W00</a></p>



<h3 id="variant">variant</h3>

<p>Represents a type-safe union. An instance of std::variant at any given time either holds a value of one of its alternative types, or it holds no value.</p>

<p>As with unions, if a variant holds a value of some object type T, the object representation of T is allocated directly within the object representation of the variant itself. Variant is not allowed to allocate additional (dynamic) memory. <br>
A variant is not permitted to hold references, arrays, or the type void. <br>
As with unions, the default-initialized variant holds a value of its first alternative, unless that alternative is not default-constructible (in which case default constructor won’t compile: the helper class std::monostate can be used to make such variants default-constructible).</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> Visitor {
  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt; <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>()(T...) <span class="hljs-keyword">const</span> {} 
  <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">const</span> {}
  <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>) <span class="hljs-keyword">const</span> {} 
  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>()(<span class="hljs-built_in">string</span>, T) <span class="hljs-keyword">const</span> {}
};

variant&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">string</span>,<span class="hljs-keyword">double</span>&gt; i{ <span class="hljs-number">10</span> }, str{ <span class="hljs-string">"hi"</span> };

<span class="hljs-comment">// valid (or nullptr) - noexcept</span>
<span class="hljs-keyword">auto</span> intPtr = get_if&lt;<span class="hljs-keyword">int</span>&gt;(i); 
<span class="hljs-keyword">auto</span> nullPtr = get_if&lt;<span class="hljs-keyword">double</span>&gt;(str); 
<span class="hljs-comment">// valid (or throws std::bad_variant_access)</span>
<span class="hljs-keyword">auto</span>&amp; strRef = get&lt;<span class="hljs-built_in">string</span>&gt;(str);

Visitor v;
visit(v, i); <span class="hljs-comment">// on int</span>
visit(v, str); <span class="hljs-comment">// on T</span>

<span class="hljs-comment">// multi-visitation</span>
visit(v, i, str); <span class="hljs-comment">// on T, T</span>
visit(v, str, i); <span class="hljs-comment">// on string, T</span></code></pre>

<p>Play: <a href="http://melpon.org/wandbox/permlink/sGMv2G23hzMjVK3S">http://melpon.org/wandbox/permlink/sGMv2G23hzMjVK3S</a></p>



<h2 id="attributes">Attributes</h2>

<p>Documentation: <a href="http://en.cppreference.com/w/cpp/language/attributes">http://en.cppreference.com/w/cpp/language/attributes</a></p>

<p>Attributes provide the unified standard syntax for implementation-defined language extensions. An attribute can be used almost everywhere in the C++ program, and can be applied to almost everything: to types, to variables, to functions, to names, to code blocks, to entire translation units, although each particular attribute is only valid where it is permitted by the implementation.</p>

<p>Besides the standard attributes listed below, implementations may support arbitrary non-standard attributes with implementation-defined behavior. That’s possibile thanks to C++17 that introduces the following rule: “attributes unknown to an implementation are ignored without causing an error”.</p>

<p>Modern library like the <a href="https://github.com/Microsoft/GSL">GSL</a> already started using custom attributes, like [[gsl::suppress]].</p>

<p>New C++17 standard attributes:</p>

<p><strong>[[fallthrough]]</strong></p>

<p>Appears in a switch statement on a line of its own (technically as an attribute of a null statement), immediately before a case label. Indicates that the fall through from the previous case label is intentional and should not be diagnosed by a compiler that warns on fallthrough:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> f(<span class="hljs-keyword">int</span> n)
{
  <span class="hljs-keyword">switch</span> (n) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"case 1\n"</span>;
      [[fallthrough]];
    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-comment">// no warning on fallthrough</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"case 2\n"</span>;
      <span class="hljs-comment">//[[fallthrough]]; // decomment to silent the warning</span>
    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-comment">// compiler may warn on fallthrough</span>
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"case 4\n"</span>;
      <span class="hljs-comment">// [[fallthrough]]; // ill formed, not before a case label</span>
  }
}</code></pre>

<p><strong>[[nodiscard]]</strong></p>

<p>Appears in a function declaration, enumeration declaration, or class declaration. If a function declared nodiscard or a function returning an enumeration or class declared nodiscard by value is called from a discarded-value expression other than a cast to void, the compiler is encouraged to issue a warning:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">struct</span> [[nodiscard]] handle { <span class="hljs-keyword">int</span> secret; };

handle LoadModule(string_view name)
{
    <span class="hljs-keyword">if</span> (name == <span class="hljs-string">"module1"</span>)
        <span class="hljs-keyword">return</span> {<span class="hljs-number">10</span>}; 
    <span class="hljs-keyword">return</span> {}; <span class="hljs-comment">// suppose invalid</span>
}

[[nodiscard]] <span class="hljs-keyword">int</span> LastErrorCode()
{
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

LoadModule(<span class="hljs-string">"module"</span>); <span class="hljs-comment">// warning encouraged</span>

LastErrorCode(); <span class="hljs-comment">// warning encouraged</span>
</code></pre>

<p><strong>[[maybe_unused]]</strong></p>

<p>Appears in the declaration of a class, a typedef­, a variable, a non­static data member, a function, an enumeration, or an enumerator. If the compiler issues warnings on unused entities, that warning is suppressed for any entity declared maybe_unused:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-comment">// v--- the function may be unused</span>
 [[maybe_unused]] <span class="hljs-keyword">void</span> unused([[maybe_unused]] <span class="hljs-keyword">bool</span> thing1, [[maybe_unused]] <span class="hljs-keyword">bool</span> thing2)
{
   [[maybe_unused]] <span class="hljs-keyword">bool</span> b = thing1 &amp;&amp; thing2;
   assert(b); <span class="hljs-comment">// in release mode, assert is compiled out, and b is unused</span>
              <span class="hljs-comment">// no warning because it is declared [[maybe_unused]]</span>
} <span class="hljs-comment">// parameters thing1 and thing2 are not used, no warning</span></code></pre>

<p>Play: <a href="http://melpon.org/wandbox/permlink/sIo3MzPDlUxm1OjX">http://melpon.org/wandbox/permlink/sIo3MzPDlUxm1OjX</a></p>



<h2 id="generic-programming">Generic Programming</h2>



<h3 id="apply-invoke">apply &amp; invoke</h3>

<p>Documentation: <a href="http://en.cppreference.com/w/cpp/utility/apply">http://en.cppreference.com/w/cpp/utility/apply</a>  <br>
and <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke">http://en.cppreference.com/w/cpp/utility/functional/invoke</a></p>

<p>std::apply invokes a callable object by unpacking a tuple into its arguments:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> print(<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>, Foo);

tuple args{<span class="hljs-string">"hello"</span>s, <span class="hljs-number">10</span>, Foo{}};
<span class="hljs-built_in">std</span>::apply(print, args);</code></pre>

<p>std::invoke is the “unzipped” version of std::apply: it invokes the callable object with the parameters passed:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> print(<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>, Foo);

<span class="hljs-built_in">std</span>::invoke(print, <span class="hljs-string">"hello"</span>s, <span class="hljs-number">10</span>, Foo{});</code></pre>

<p>Play: <a href="http://melpon.org/wandbox/permlink/CbiNcRsGE5YrEnPZ">http://melpon.org/wandbox/permlink/CbiNcRsGE5YrEnPZ</a></p>



<h3 id="makefromtuple">make_from_tuple</h3>

<p>Documentation: <a href="http://en.cppreference.com/w/cpp/utility/tuple/make_tuple">http://en.cppreference.com/w/cpp/utility/tuple/make_tuple</a></p>

<p>std::make_from_tuple constructs an object of a certain type, using the elements of a tuple as the arguments to the constructor:</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;
<span class="hljs-keyword">class</span> MyContainer
{
   <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;K&gt;</span> keys;
   <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;V&gt;</span> values;
<span class="hljs-keyword">public</span>:
   <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> KeyTuple, <span class="hljs-keyword">typename</span> ValueTuple&gt;
   <span class="hljs-keyword">void</span> emplace(<span class="hljs-built_in">std</span>::piecewise_construct_t, KeyTuple&amp;&amp; kt, ValueTuple&amp;&amp; vt)
   {
     <span class="hljs-comment">// ... some complex logic</span>
     keys.push_back(make_from_tuple&lt;K&gt;(kt));
     values.push_back(make_from_tuple&lt;V&gt;(vt));
   }
};</code></pre>

<p>Play: <a href="http://melpon.org/wandbox/permlink/OAeVL7N8NwAWlN5o">http://melpon.org/wandbox/permlink/OAeVL7N8NwAWlN5o</a></p>



<h3 id="if-constexpr">if constexpr</h3>

<p>Documentation: <a href="http://en.cppreference.com/w/cpp/language/if#Constexpr_If">http://en.cppreference.com/w/cpp/language/if#Constexpr_If</a></p>

<p>In a <em>constexpr if</em> statement, the value of condition must be a contextually converted constant expression of type bool. If the value is true, then statement-false is discarded (if present), otherwise, statement-true is discarded. <br>
The return statements in a discarded statement do not participate in function return type deduction.</p>



<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> OS { Linux, Mac, Windows };

<span class="hljs-preprocessor">#ifdef __linux__</span>
  <span class="hljs-keyword">constexpr</span> OS curr_os = OS::Linux;
<span class="hljs-preprocessor">#elif __APPLE__</span>
  <span class="hljs-keyword">constexpr</span> OS curr_os = OS::Mac;
<span class="hljs-preprocessor">#elif __WIN32</span>
  <span class="hljs-keyword">constexpr</span> OS curr_os = OS::Windows;
<span class="hljs-preprocessor">#endif</span>

<span class="hljs-keyword">void</span> do_something() {
     <span class="hljs-comment">//do something general</span>

     <span class="hljs-keyword">if</span> <span class="hljs-keyword">constexpr</span> (curr_os == OS::Linux) {
         <span class="hljs-comment">//do something Linuxy</span>
     }
     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">constexpr</span> (curr_os == OS::Mac) {
         <span class="hljs-comment">//do something Appley</span>
     }
     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">constexpr</span> (curr_os == OS::Windows) {
         <span class="hljs-comment">//do something Windowsy</span>
     }

     <span class="hljs-comment">//do something general</span>
}</code></pre>

<p>Play: <a href="http://melpon.org/wandbox/permlink/g1bceK9eVAMgWvBq">http://melpon.org/wandbox/permlink/g1bceK9eVAMgWvBq</a></p></div></body>
</html>
